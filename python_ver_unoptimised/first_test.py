import numpy as np
import random as rd
import matplotlib.pyplot as plt
import vaex



from CGAL.CGAL_Kernel import Point_2
from CGAL.CGAL_Triangulation_2 import Delaunay_triangulation_2
from CGAL.CGAL_Triangulation_2 import VERTEX
from CGAL.CGAL_Triangulation_2 import Triangulation_2_Vertex_circulator
from CGAL.CGAL_Triangulation_2 import Triangulation_2_Vertex_handle
from CGAL.CGAL_Kernel import Ref_int
from CGAL.CGAL_Triangulation_2 import Ref_Locate_type_2
from CGAL.CGAL_Triangulation_2 import Constrained_Delaunay_triangulation_2




'''
Dans toute la suite
v - vertex handle
vp- vertex point

'''

fig, ax = plt.subplots(nrows=2, ncols=2, figsize=(18, 5))







'''
@param : none
@function : generates a Point_2 type which is randomly placed with x and y in the interval [0,1]
'''
def point_generator():
	return Point_2(rd.uniform(-0.5, 0.5),rd.uniform(-0.5, 0.5))


'''
@param : n - integer - number of points to generate
@funtion : creates a list of points which have been generated by point_generator
'''
def total_drops(n):
	L=[]
	for i in range(0,n):
		L.append(point_generator())
	return L



'''
@param : -handle v 
	 -L list of points
	 -triangulation T
	 - z integer for the position of subplot	
	 - i which element to remove
@f : remove a handle (ex : v1) and returns the point
'''
def remove(T,L,v_handles,i,z):
	T.remove(v_handles[i])
	l = L[i]
	del L[i]
	ax[z[0],z[1]].scatter(l.x(),l.y(),color ='red')
	return l

'''
@param : -handle v 
	 -L list of points
	 -triangulation T
	 - z integer for the position of subplot
	 - i which element to remove	
@f : Insert a random point(ex : vp) and returns the point
'''
def add(T,L,z):
	vp = Point_2(rd.uniform(-0.5, 0.5),rd.uniform(-0.5, 0.5))
	vpt = T.insert(vp) # handle of vp
	L.append(vp)
	ax[z[0],z[1]].scatter(vp.x(),vp.y(),color ='hotpink')
	return vpt
	


def add_draw(vp):
	list_del_points = connected_points(T,vpt)






'''
@param : L : list of points
@f : extracts x and y coordinates of said point 
Note : useful just to visualize
'''
def extract(L):
	point_list = []
	for i in L:
		point_list.append((i.x(), i.y()))
	
	point_list = np.array(point_list)
	transposed = point_list.T
	
	x, y = transposed 
	
	return x,y
	

'''
@param : l list of tuples
@f : converts the lst of tuples to a format where scatter functions
'''
def scatter_convert(l):
	point_list = np.array(l)
	transposed = point_list.T #.T is transpose 
	
	x, y = transposed 
	
	return x,y
	
	
	
'''
@param : - Vertex/handle v1 
	 - T the delaunay construction
@f: finds all the connected points(coordinates) to which v1 is connected to after delaunay triangulisation
'''	
def connected_points(T,v1):
	circulator = T.incident_vertices(v1) # starting at the point v1
	done = circulator.next() # going to the next point
	list_del_points = [] # list of linked points to the point considered

	while(1):
	  v = circulator.next()
	  vp = v.point() # vp is the point associated to the vertex v on the circulator
	  list_del_points.append((vp.x(),vp.y()))
	  if v == done:
	    break
	return list_del_points
	
'''
@param : - Vertex/handle v1 
	 - T the delaunay construction
@f: finds all the connected vertexes to which v1 is connected to after delaunay triangulisation
'''	
def connected_vertexs(T,v1):
	circulator = T.incident_vertices(v1) # starting at the point v1
	done = circulator.next() # going to the next point
	list_del_points = [] # list of linked points to the point considered

	while(1):
	  v = circulator.next()
	  vv = v.point() # v
	  list_del_points.append(vv)
	  if v == done:
	    break
	return list_del_points








'''
@param : points
	- z tuple for the position of subplot
@f: draw an edge between the two vertexes without movement
'''	
def draw_edge(v1,v2,z): 
	ax[z[0],z[1]].plot([v1.x(),v2.x()],[v1.y(),v2.y()],color='black',linewidth=0.3)
	ax[z[0],z[1]].scatter([v1.x(),v2.x()],[v1.y(),v2.y()],color='blue',s= 10)
	

'''
@param : points
	- z tuple for the position of subplot
@f: draw an edge between the two vertexes without movement with color choice
'''	
def draw_edge_color(v1,v2,z,c): 
	ax[z[0],z[1]].plot([v1.x(),v2.x()],[v1.y(),v2.y()],color=c,linewidth=5)
	ax[z[0],z[1]].scatter([v1.x(),v2.x()],[v1.y(),v2.y()],color=c,s= 200)
	
	





	
'''

@param :-two points (coordinates)
	- z integer for the position of subplot
@f: draw and edge between the points
'''

def draw_edge_points(x1,y1,x2,y2,z):
	ax[z[0],z[1]].plot(x, y, label='a').plot([x1,x2],[y1,y2],color='black',lw='0.3')
	
	
'''
@param : -T triangulation
	 -L list of points
	 - z integer for the position of subplot
# A OPTIMISER POUR LA RAISON QUE ON REGARDE/DESSINE LE MEME EDGE 2 FOIS

'''

def calc_triang_draw(T,L,z):
	list_handles = [] # list of handles
	for i in L: # for each point in L
		w = T.insert(i)
		list_handles.append(w)
	assert(len(list_handles) == len(L))
	for k in range(len(list_handles)): # for each vertex handle in list_handles (so for each point in L)
		list_del_points = connected_points(T,list_handles[k]) # calculate the connected points 
		print(list_del_points)
		connected = scatter_convert(list_del_points) # formatting
		for j in range(len(connected)) : # for each connected point 
			draw_edge_points(connected[0][j],connected[1][j],L[k].x(),L[k].y(),z) # optimisable				
	return list_handles

def calc_triang_draw2(T,L,z):
	list_handles = [] # list of handles
	for i in L:
		w = T.insert(i)
		list_handles.append(w)
		list_del_vertex = connected_vertexs(T,w) 
		for j in list_del_vertex : 
			draw_edge(i,j,z) # optimisable
	return list_handles
			
	





def draw_droplets(L):
	pts = extract(L)
	plt.scatter(pts[0],pts[1],s=10)


'''

@f: Draws all the edges only for one point
'''

def draw_singular_connected_edges(T,L,v,z):
	list_del_points = connected_points(T,v) # list of delaunays connected points of one vertex v
	print('list -------------',list_del_points)
	connected = scatter_convert(list_del_points)
	ax[z[0],z[1]].scatter(connected[0],connected[1],s=80,color = 'green')
	for i in range(len(list_del_points)):
		draw_edge_color(L[i],list_del_points[i],(1,0),'red')
		
		
	
	
	
	
	
	
			






'''
def draw_all_edges(T,L):
	for v in L: 
		list_del_points = connected_points(T,v) # calculating the vertexs
		cp= scatter_convert(list_del_points)
		print('CP 0 ============== ',cp[0])
		for j in cp:
			draw_edge_points([v.x(),j[0]],[v.y(),j[1]])
	 		
'''
	 		

	
'''
@param : -vertex1 and vertex2
@f: calculate the euclidean distance between the CDM two vertices
'''
def distance(v1,v2):
	return np.sqrt((v1.x()-v2.x())**2 + (v1.y()-v2.y())**2)
	
	
	



	


	
	



		


